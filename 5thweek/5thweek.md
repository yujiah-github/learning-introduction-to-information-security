정보보호개론7주차 - 5장 요약 과제

정보통신공학전공
201814140 유지아
메모리의 기본 구조
크게 스택과 힙으로 구분된다. 스택은 프로그램 로직이 동작하기 위한 인자와 프로세스 상태를 저장하는 데 사용되고 힙은 프로그램이 동작할 때 필요한 데이터 정보를 임시로 저장하는 데 사용된다.

En/.argv 문자열, 포인터 – 환경 변수와 명령 창의 데이터 저장
스택 영역 – 로컬 인자와 프로세스 상태 저장
힙 영역 – 동적으로 할당된 데이터 저장
데이터(.BSS) – 초기화되지 않은 변수
데이터(.DATA) – 초기화된 변수
코드 – 보통 읽을 수 있는 부분이 있으나 변조될 경우 세그먼테이션 오류 발생

80x86 cpu의 주요 레지스터
범용 레지스터 – EAX, EBX, ECX, EDX (비트는 모두 32)
누산기: 산술 연산에 사용
베이스 레지스터: 특정 주소 저장
카운트 레지스터: 반복적으로 실행되는 특정 명령에 사용(루프의 반복 횟수나 좌우 방향 시프트 비트 수 기억)
데이터 레지스터: 일반 데이터 저장(입출력 동작에 사용)

포인터 레지스터 – EBP, ESP(비트는 모두 32)
베이스 포인터: SS 레지스터와 함께 스택 내의 변수값을 읽는 데 사용
스택 포인터: SS 레지스터와 함께 스택의 가장 끝 주소를 가리킴
셸
운영 체제를 둘러싸고 있으면서 입력받는 명령어를 실행하는 명령어 해석기다.

프로세스 권한과 SETUID
각 계정에는 고유한 uid 가 있는데, setuid가 부여된 프로그램을 실행할 때는 다음과 같이 임시로 권한을 바꿀 수 있다.
Test에 setuid 비트가 있는 경우 프로세스 권한 변경
Test실행 전 > test 실행 시 권한 전환 > test 실행 중 root 권한 획득 > test 종료시 권환 전환 > test 실행 후
Test에 setuid 비트가 없는 경우 프로세스 권한
Test 실행 전 > test 실행 시 권한 전환 없음> test 종료 시 권한 전환 없음 > test 실행 후

버퍼 오버플로 공격
데이터의 길이에 대한 불명확한 정의를 악용한 덮어쓰기로 발생한다. 정상적인 경우에는 사용되지 않아야 할 주소 공간, 즉 원래는 경계선 관리가 적절하게 수행되어 덮어쓸 수 없는 부분에 해커가 임의의 코드를 덮어쓰는 공격이다.
버퍼 오버플로 공격의 대응책 중 하나는 버퍼 오버플로에 취약한 다음과 같은 함수를 사용하지 않는 것이다.
- strcpy(char *dest, const char *src);
- strcat(char *dest, const char *src);
- getwd(char *buf);
- fscan(FILE *stream, const char *format);
- scanf(const char * format);
- realpath(char *path, char resolved_path[]);
- sprint(char *str, const char *format)

포맷 스트링 공격
데이터 형태에 대한 불명확한 정의로 발생한다. 버퍼 오버플로 공격처럼 ret 값을 변조하여 임의의 코드를 실행할 수 있다.
포맷 스트링 문자의 종류
%d – 정수형 10진수 상수
%f – 실수형 상수
%lf – 실수형 상수 (더블)
%s – 문자 스트링
%u – 양의 정수(10진수)
%o – 양의 정수 (8진수)
%x – 양의 정수 (16진수)
%s – 문자열
%n - *int(쓰인 총 바이트 수)
%hn - %n 의 절반인 2바이트 단위

메모리 해킹
프로그램의 동작에 관여하지 않고, 프로그램이 실행되는 데 필요한 정보를 저장해둔 메모리를 직접 조작하여 프로그램 실행에 관여하는 공격 방법이다.
